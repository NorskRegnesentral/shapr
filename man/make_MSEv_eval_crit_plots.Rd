% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot.R
\name{make_MSEv_eval_crit_plots}
\alias{make_MSEv_eval_crit_plots}
\title{Plots of the MSEv Evaluation Criterion}
\usage{
make_MSEv_eval_crit_plots(
  explanation_list,
  index_x_explain = NULL,
  id_combination = NULL,
  level = 0.95,
  geom_col_width = 0.9,
  make_MSEv_comb_and_explicand = FALSE
)
}
\arguments{
\item{explanation_list}{A list of \code{\link[=explain]{explain()}} objects applied to the same data and model.
If the entries in the list are named, then the function use these names. Otherwise, they default to
the approach names (with integer suffix for duplicates) for the explanation objects in \code{explanation_list}.}

\item{index_x_explain}{Integer vector.
Which of the test observations to plot. E.g. if you have
explained 10 observations using \code{\link[=explain]{explain()}}, you can generate a plot for the first 5
observations by setting \code{index_x_explain = 1:5}.}

\item{id_combination}{Integer vector. Which of the combinations (coalitions) to plot.
E.g. if you used \code{n_combinations = 16} in \code{\link[=explain]{explain()}}, you can generate a plot for the
first 5 combinations and the 10th by setting \code{index_x_explain = c(1:5, 10)}.}

\item{level}{Positive numeric between zero and one (default is \code{0.95}). The level of the approximate
confidence intervals for the overall MSEv and the MSEv_combination. Setting \code{level = NULL} removes the
confidence intervals. The confidence intervals are based on that
the MSEv scores are means over the observations/explicands, and that means are approximation normal. Since the
standard deviations are estimated, we use the quantile t from the T distribution with N_explicands - 1 degrees of
freedom corresponding to the provided level. Here, N_explicands is the number of observations/explicands.
MSEv ± t\emph{SD(MSEv)/sqrt(N_explicands). Note that the \code{explain()} function already scales the standard deviation by
sqrt(N_explicands), thus, the CI are MSEv ± t}MSEv_sd, where the values MSEv and MSEv_sd are extracted from the
MSEv data.tables in the objects in the \code{explanation_list}.}

\item{geom_col_width}{Numeric. Bar width. By default, set to 90\% of the \code{\link[ggplot2:resolution]{ggplot2::resolution()}} of the data.}

\item{make_MSEv_comb_and_explicand}{Logical. If \code{FALSE} (default), then only the plot associated with the overall
MSEv criterion is created (i.e., when averaging over both the combinations and observations). When \code{TRUE},
the function also creates figures illustrating the MSEv evaluation criterion for each observation and combination
by only averaging over the combinations and observations, respectively.}
}
\value{
A \code{\link[ggplot2:ggplot]{ggplot2::ggplot()}} object of the MSEv criterion. If \code{make_MSEv_comb_and_explicand = TRUE},
then a list of  5 \code{\link[ggplot2:ggplot]{ggplot2::ggplot()}} objects are returned (three bar plots and two line plots),
where the additional fiugres are the MSEv criterion when only averaged over either the combinations
or the test observations.
}
\description{
Make plots to visualize and compare the MSEv evaluation criterion for a list of
\code{\link[=explain]{explain()}} objects applied to the same data and model. The function creates
bar plots and line plots with points to illustrate the overall MSEv evaluation
criterion, but also for each observation/explicand and combination by only averaging over
the combinations and observations/explicands, respectively.
}
\examples{
# Load necessary librarieslibrary(xgboost)
library(data.table)
library(shapr)
library(ggplot2)

# Get the data
data("airquality")
data <- data.table::as.data.table(airquality)
data <- data[complete.cases(data), ]

#' Define the features and the response
x_var <- c("Solar.R", "Wind", "Temp", "Month")
y_var <- "Ozone"

# Split data into test and training data set
ind_x_explain <- 1:25
x_train <- data[-ind_x_explain, ..x_var]
y_train <- data[-ind_x_explain, get(y_var)]
x_explain <- data[ind_x_explain, ..x_var]

# Fitting a basic xgboost model to the training data
model <- xgboost::xgboost(
  data = as.matrix(x_train),
  label = y_train,
  nround = 20,
  verbose = FALSE
)

# Specifying the phi_0, i.e. the expected prediction without any features
prediction_zero <- mean(y_train)

# Independence approach
explanation_independence <- explain(
  model = model,
  x_explain = x_explain,
  x_train = x_train,
  approach = "independence",
  prediction_zero = prediction_zero,
  n_samples = 1e2
)

# Gaussian 1e1 approach
explanation_gaussian_1e1 <- explain(
  model = model,
  x_explain = x_explain,
  x_train = x_train,
  approach = "gaussian",
  prediction_zero = prediction_zero,
  n_samples = 1e1
)

# Gaussian 1e2 approach
explanation_gaussian_1e2 <- explain(
  model = model,
  x_explain = x_explain,
  x_train = x_train,
  approach = "gaussian",
  prediction_zero = prediction_zero,
  n_samples = 1e2
)

# ctree approach
explanation_ctree <- explain(
  model = model,
  x_explain = x_explain,
  x_train = x_train,
  approach = "ctree",
  prediction_zero = prediction_zero,
  n_samples = 1e2
)

# Combined approach
explanation_combined <- explain(
  model = model,
  x_explain = x_explain,
  x_train = x_train,
  approach = c("gaussian", "independence", "ctree"),
  prediction_zero = prediction_zero,
  n_samples = 1e2
)

# Create a list of explanations with names
explanation_list_named <- list(
  "Ind." = explanation_independence,
  "Gaus. 1e1" = explanation_gaussian_1e1,
  "Gaus. 1e2" = explanation_gaussian_1e2,
  "Ctree" = explanation_ctree,
  "Combined" = explanation_combined
)

if (requireNamespace("ggplot2", quietly = TRUE)) {
  # Create the default MSEv plot where we average over both the combinations and observations
  # with approximate 95\% confidence intervals
  make_MSEv_eval_crit_plots(explanation_list_named, level = 0.95)

  # Can also create plots of the MSEv criterion averaged only over the combinations or observations.
  MSEv_figures <- make_MSEv_eval_crit_plots(explanation_list_named,
    level = 0.95,
    make_MSEv_comb_and_explicand = TRUE
  )
  MSEv_figures$MSEv_bar
  MSEv_figures$MSEv_combination_bar
  MSEv_figures$MSEv_explicand_bar

  # When there are many combinations or observations, then it can be easier to look at line plots
  MSEv_figures$MSEv_combination_line_point
  MSEv_figures$MSEv_explicand_line_point

  # We can specify which observations or combinations to plot
  make_MSEv_eval_crit_plots(explanation_list_named,
    make_MSEv_comb_and_explicand = TRUE,
    index_x_explain = c(1, 3:4, 6),
    level = 0.95
  )$MSEv_explicand_bar
  make_MSEv_eval_crit_plots(explanation_list_named,
    make_MSEv_comb_and_explicand = TRUE,
    id_combination = c(3, 4, 9, 13:15),
    level = 0.95
  )$MSEv_combination_bar

  # We can alter the figures if other palette schemes or design is wanted
  bar_text_n_decimals <- 1
  MSEv_figures$MSEv_bar +
    ggplot2::scale_x_discrete(limits = rev(levels(MSEv_figures$MSEv_bar$data$Method))) +
    ggplot2::coord_flip() +
    ggplot2::scale_fill_discrete() + #' Default ggplot2 palette
    ggplot2::theme_minimal() + #' This must be set before the other theme call
    ggplot2::theme(
      plot.title = ggplot2::element_text(size = 10),
      legend.position = "bottom"
    ) +
    ggplot2::guides(fill = ggplot2::guide_legend(nrow = 1, ncol = 6)) +
    ggplot2::geom_text(
      ggplot2::aes(label = sprintf(
        paste("\%.", sprintf("\%d", bar_text_n_decimals), "f", sep = ""),
        round(MSEv, bar_text_n_decimals)
      )),
      vjust = -1.1, # This value must be altered based on the plot dimension
      hjust = 1.1, # This value must be altered based on the plot dimension
      color = "black",
      position = ggplot2::position_dodge(0.9),
      size = 5
    )
}

}
\author{
Lars Henry Berge Olsen
}
