# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Computing single H matrix in AICc-function using the Mahalanobis distance
#'
#' @param X matrix with "covariates"
#' @param mcov covariance matrix
#' @param S_scale_dist logical indicating whether the Mahalanobis distance should be scaled with the number of variables
#' @param h numeric specifying the scaling (sigma)
#'
#' @export
#' @keywords internal
#'
#' @return Matrix of dimension \code{ncol(X)*ncol(X)}
#' @author Martin Jullum
hat_matrix_cpp <- function(X, mcov, S_scale_dist, h) {
    .Call(`_shapr_hat_matrix_cpp`, X, mcov, S_scale_dist, h)
}

#' sigma_hat_sq-function
#'
#' @param H Matrix. Output from \code{\link{hat_matrix_cpp}}
#' @param y Vector, i.e. representing the response variable
#'
#' @export
#' @keywords internal
#'
#' @return Scalar
#'
#' @author Martin Jullum
rss_cpp <- function(H, y) {
    .Call(`_shapr_rss_cpp`, H, y)
}

#' correction term with trace_input in AICc formula
#'
#' @param tr_H numeric giving the trace of H
#' @param n numeric given the number of rows in H
#' @export
#' @keywords internal
#'
#' @return Scalar
#' @author Martin Jullum
correction_matrix_cpp <- function(tr_H, n) {
    .Call(`_shapr_correction_matrix_cpp`, tr_H, n)
}

#'  Temp-function for computing the full AICc with several X's etc
#'
#' @param X matrix with "covariates"
#' @param mcov covariance matrix
#' @param S_scale_dist logical indicating whether the Mahalanobis distance should be scaled with the number of variables
#' @param h numeric specifying the scaling (sigma)
#' @param y vector with the "response variable"
#'
#' @export
#' @keywords internal
#'
#' @return Scalar with the numeric value of the AICc formula
#' @author Martin Jullum
aicc_full_single_cpp <- function(X, mcov, S_scale_dist, h, y) {
    .Call(`_shapr_aicc_full_single_cpp`, X, mcov, S_scale_dist, h, y)
}

#'  AICc formula for several sets, alternative definition
#'
#' @param h Numeric. Specifies the scaling (sigma)
#' @param X_list List
#' @param mcov_list List
#' @param S_scale_dist Logical. Indicates whether Mahalanobis distance should be scaled with the
#' number of variables
#' @param y_list List.
#' @param negative Logical.
#' @keywords internal
#'
#' @return Scalar with the numeric value of the AICc formula
#'
#' @author Martin Jullum
aicc_full_cpp <- function(h, X_list, mcov_list, S_scale_dist, y_list, negative) {
    .Call(`_shapr_aicc_full_cpp`, h, X_list, mcov_list, S_scale_dist, y_list, negative)
}

#' Compute the quantiles using quantile type seven
#'
#' @details Using quantile type number seven from stats::quantile in R.
#'
#' @param x arma::vec. Numeric vector whose sample quantiles are wanted.
#' @param probs arma::vec. Numeric vector of probabilities with values between zero and one.
#'
#' @return A vector of length `length(probs)` with the quantiles is returned.
#'
#' @keywords internal
#' @author Lars Henry Berge Olsen
quantile_type7_cpp <- function(x, probs) {
    .Call(`_shapr_quantile_type7_cpp`, x, probs)
}

#' Transforms new data to a standardized normal distribution
#'
#' @param z arma::mat. The data are the Gaussian Monte Carlos samples to transform.
#' @param x arma::mat. The data with the original transformation. Used to conduct the transformation of `z`.
#'
#' @return arma::mat of the same dimension as `z`
#'
#' @keywords internal
#' @author Lars Henry Berge Olsen
inv_gaussian_transform_cpp <- function(z, x) {
    .Call(`_shapr_inv_gaussian_transform_cpp`, z, x)
}

#' Generate (Gaussian) Copula MC samples
#'
#' @param MC_samples_mat arma::mat. Matrix of dimension (`n_MC_samples`, `n_features`) containing samples from the
#' univariate standard normal.
#' @param x_explain_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing the observations
#' to explain on the original scale.
#' @param x_explain_gaussian_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing the
#' observations to explain after being transformed using the Gaussian transform, i.e., the samples have been
#' transformed to a standardized normal distribution.
#' @param x_train_mat arma::mat. Matrix of dimension (`n_train`, `n_features`) containing the training observations.
#' @param S arma::mat. Matrix of dimension (`n_coalitions`, `n_features`) containing binary representations of
#' the used coalitions. S cannot contain the empty or grand coalition, i.e., a row containing only zeros or ones.
#' This is not a problem internally in shapr as the empty and grand coalitions treated differently.
#' @param mu arma::vec. Vector of length `n_features` containing the mean of each feature after being transformed
#' using the Gaussian transform, i.e., the samples have been transformed to a standardized normal distribution.
#' @param cov_mat arma::mat. Matrix of dimension (`n_features`, `n_features`) containing the pairwise covariance
#' between all pairs of features after being transformed using the Gaussian transform, i.e., the samples have been
#' transformed to a standardized normal distribution.
#'
#' @return An arma::cube/3D array of dimension (`n_MC_samples`, `n_explain` * `n_coalitions`, `n_features`), where
#' the columns (_,j,_) are matrices of dimension (`n_MC_samples`, `n_features`) containing the conditional Gaussian
#' copula MC samples for each explicand and coalition on the original scale.
#'
#' @export
#' @keywords internal
#' @author Lars Henry Berge Olsen
prepare_data_copula_cpp <- function(MC_samples_mat, x_explain_mat, x_explain_gaussian_mat, x_train_mat, S, mu, cov_mat) {
    .Call(`_shapr_prepare_data_copula_cpp`, MC_samples_mat, x_explain_mat, x_explain_gaussian_mat, x_train_mat, S, mu, cov_mat)
}

#' Generate (Gaussian) Copula MC samples for the causal setup with a single MC sample for each explicand
#'
#' @param MC_samples_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing samples from the
#' univariate standard normal. The i'th row will be applied to the i'th row in `x_explain_mat`.
#' @param x_explain_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing the observations to
#' explain on the original scale. The MC sample for the i'th explicand is based on the i'th row in `MC_samples_mat`.
#' @param x_explain_gaussian_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing the
#' observations to explain after being transformed using the Gaussian transform, i.e., the samples have been
#' transformed to a standardized normal distribution.
#' @param x_train_mat arma::mat. Matrix of dimension (`n_train`, `n_features`) containing the training observations.
#' @param S arma::mat. Matrix of dimension (`n_coalitions`, `n_features`) containing binary representations of
#' the used coalitions. S cannot contain the empty or grand coalition, i.e., a row containing only zeros or ones.
#' This is not a problem internally in shapr as the empty and grand coalitions treated differently.
#' @param mu arma::vec. Vector of length `n_features` containing the mean of each feature after being transformed
#' using the Gaussian transform, i.e., the samples have been transformed to a standardized normal distribution.
#' @param cov_mat arma::mat. Matrix of dimension (`n_features`, `n_features`) containing the pairwise covariance
#' between all pairs of features after being transformed using the Gaussian transform, i.e., the samples have been
#' transformed to a standardized normal distribution.
#'
#' @return An arma::mat/2D array of dimension (`n_explain` * `n_coalitions`, `n_features`),
#' where the rows (n_explain * S_ind, n_explain * (S_ind + 1) - 1) contains the single
#' conditional Gaussian MC samples for each explicand and `S_ind` coalition.
#'
#' @export
#' @keywords internal
#' @author Lars Henry Berge Olsen
prepare_data_copula_cpp_caus <- function(MC_samples_mat, x_explain_mat, x_explain_gaussian_mat, x_train_mat, S, mu, cov_mat) {
    .Call(`_shapr_prepare_data_copula_cpp_caus`, MC_samples_mat, x_explain_mat, x_explain_gaussian_mat, x_train_mat, S, mu, cov_mat)
}

#' Generate Gaussian MC samples
#'
#' @param MC_samples_mat arma::mat. Matrix of dimension (`n_MC_samples`, `n_features`) containing samples from the
#' univariate standard normal.
#' @param x_explain_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing the observations
#' to explain.
#' @param S arma::mat. Matrix of dimension (`n_coalitions`, `n_features`) containing binary representations of
#' the used coalitions. S cannot contain the empty or grand coalition, i.e., a row containing only zeros or ones.
#' This is not a problem internally in shapr as the empty and grand coalitions treated differently.
#' @param mu arma::vec. Vector of length `n_features` containing the mean of each feature.
#' @param cov_mat arma::mat. Matrix of dimension (`n_features`, `n_features`) containing the pairwise covariance
#' between all pairs of features.
#'
#' @return An arma::cube/3D array of dimension (`n_MC_samples`, `n_explain` * `n_coalitions`, `n_features`), where
#' the columns (_,j,_) are matrices of dimension (`n_MC_samples`, `n_features`) containing the conditional Gaussian
#' MC samples for each explicand and coalition.
#'
#' @export
#' @keywords internal
#' @author Lars Henry Berge Olsen
prepare_data_gaussian_cpp <- function(MC_samples_mat, x_explain_mat, S, mu, cov_mat) {
    .Call(`_shapr_prepare_data_gaussian_cpp`, MC_samples_mat, x_explain_mat, S, mu, cov_mat)
}

#' Generate Gaussian MC samples for the causal setup with a single MC sample for each explicand
#'
#' @param MC_samples_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing samples from the
#' univariate standard normal. The i'th row will be applied to the i'th row in `x_explain_mat`.
#' @param x_explain_mat arma::mat. Matrix of dimension (`n_explain`, `n_features`) containing the observations
#' to explain. The MC sample for the i'th explicand is based on the i'th row in `MC_samples_mat`
#' @param S arma::mat. Matrix of dimension (`n_combinations`, `n_features`) containing binary representations of
#' the used coalitions. S cannot contain the empty or grand coalition, i.e., a row containing only zeros or ones.
#' This is not a problem internally in shapr as the empty and grand coalitions treated differently.
#' @param mu arma::vec. Vector of length `n_features` containing the mean of each feature.
#' @param cov_mat arma::mat. Matrix of dimension (`n_features`, `n_features`) containing the pairwise covariance
#' between all pairs of features.
#'
#' @return An arma::mat/2D array of dimension (`n_explain` * `n_coalitions`, `n_features`),
#' where the rows (n_explain * S_ind, n_explain * (S_ind + 1) - 1) contains the single
#' conditional Gaussian MC samples for each explicand and `S_ind` coalition.
#'
#' @export
#' @keywords internal
#' @author Lars Henry Berge Olsen
prepare_data_gaussian_cpp_caus <- function(MC_samples_mat, x_explain_mat, S, mu, cov_mat) {
    .Call(`_shapr_prepare_data_gaussian_cpp_caus`, MC_samples_mat, x_explain_mat, S, mu, cov_mat)
}

#' (Generalized) Mahalanobis distance
#'
#' Used to get the Euclidean distance as well by setting \code{mcov} = \code{diag(m)}.
#'
#' @param featureList List of vectors indicating all factor combinations that should be included in the computations. Assumes that the first one is empty.
#' @param mcov Matrix. The Sigma-matrix in the Mahalanobis distance formula (\code{stats::cov(Xtrain_mat)}) gives Mahalanobis distance,
#' \code{diag(m)} gives the Euclidean distance.
#' @param S_scale_dist Logical indicating
#' @param Xtrain_mat Matrix
#' @param Xtest_mat Matrix
#'
#' @export
#' @keywords internal
#'
#' @return Array of three dimensions. Contains the squared distance for between all training and test observations for all feature combinations passed to the function.
#' @author Martin Jullum
mahalanobis_distance_cpp <- function(featureList, Xtrain_mat, Xtest_mat, mcov, S_scale_dist) {
    .Call(`_shapr_mahalanobis_distance_cpp`, featureList, Xtrain_mat, Xtest_mat, mcov, S_scale_dist)
}

#' @keywords internal
sample_features_cpp <- function(m, n_features) {
    .Call(`_shapr_sample_features_cpp`, m, n_features)
}

#' Get imputed data
#'
#' @param index_xtrain Positive integer. Represents a sequence of row indices from \code{xtrain},
#' i.e. \code{min(index_xtrain) >= 1} and \code{max(index_xtrain) <= nrow(xtrain)}.
#'
#' @param index_s Positive integer. Represents a sequence of row indices from \code{S},
#' i.e. \code{min(index_s) >= 1} and \code{max(index_s) <= nrow(S)}.
#'
#' @param xtrain Numeric matrix.
#'
#' @param xtest Numeric matrix. Represents a single test observation.
#'
#' @param S Integer matrix of dimension \code{n_coalitions x m}, where \code{n_coalitions} equals
#' the total number of sampled/non-sampled feature combinations and \code{m} equals
#' the total number of unique features. Note that \code{m = ncol(xtrain)}. See details
#' for more information.
#'
#' @details \code{S(i, j) = 1} if and only if feature \code{j} is present in feature
#' combination \code{i}, otherwise \code{S(i, j) = 0}. I.e. if \code{m = 3}, there
#' are \code{2^3 = 8} unique ways to combine the features. In this case \code{dim(S) = c(8, 3)}.
#' Let's call the features \code{x1, x2, x3} and take a closer look at the combination
#' represented by \code{s = c(x1, x2)}. If this combination is represented by the second row,
#' the following is true: \code{S[2, 1:3] = c(1, 1, 0)}.
#'
#' The returned object, \code{X}, is a numeric matrix where
#' \code{dim(X) = c(length(index_xtrain), ncol(xtrain))}. If feature \code{j} is present in
#' the k-th observation, that is \code{S[index_[k], j] == 1}, \code{X[k, j] = xtest[1, j]}.
#' Otherwise \code{X[k, j] = xtrain[index_xtrain[k], j]}.
#'
#' @export
#' @keywords internal
#'
#' @return Numeric matrix
#'
#' @author Nikolai Sellereite
observation_impute_cpp <- function(index_xtrain, index_s, xtrain, xtest, S) {
    .Call(`_shapr_observation_impute_cpp`, index_xtrain, index_s, xtrain, xtest, S)
}

#' Calculate weight matrix
#'
#' @param coalitions List. Each of the elements equals an integer
#' vector representing a valid combination of features/feature groups.
#' @param m Integer. Number of features/feature groups
#' @param n Integer. Number of combinations
#' @param w Numeric vector of length \code{n}, i.e. \code{w[i]} equals
#' the Shapley weight of feature/feature group combination \code{i}, represented by
#' \code{coalitions[[i]]}.
#'
#' @export
#' @keywords internal
#'
#' @return Matrix of dimension n x m + 1
#' @author Nikolai Sellereite, Martin Jullum
weight_matrix_cpp <- function(coalitions, m, n, w) {
    .Call(`_shapr_weight_matrix_cpp`, coalitions, m, n, w)
}

#' Get coalition matrix
#'
#' @param coalitions List
#' @param m Positive integer. Total number of coalitions
#'
#' @export
#' @keywords internal
#'
#' @return Matrix
#' @author Nikolai Sellereite, Martin Jullum
coalition_matrix_cpp <- function(coalitions, m) {
    .Call(`_shapr_coalition_matrix_cpp`, coalitions, m)
}

