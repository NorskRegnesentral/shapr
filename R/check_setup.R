

#' check_setup
#' @inheritParams explain
#' @export
check_setup <- function(x_train,
                        x_explain,
                        model,
                        approach,
                        prediction_zero,
                        n_combinations,
                        group,
                        n_samples,
                        n_batches,
                        seed,
                        keep_samp_for_vS,
                        predict_model,
                        get_model_specs,...){


  internal <- list()

  internal$parameters <- get_parameters(approach = approach,
                                        prediction_zero = prediction_zero,
                                        n_combinations = n_combinations,
                                        group = group,
                                        n_samples = n_samples,
                                        n_batches = n_batches,
                                        seed = seed,
                                        keep_samp_for_vS = keep_samp_for_vS,...)

  internal$data <- get_data(x_train,x_explain)

  internal$funcs <- get_funcs(predict_model,
                              get_model_specs,
                              class_model = class(model),
                              ignore_model = internal$parameters$ignore_model)


  # Extracting model specs from model
  if(!is.null(internal$funcs$get_model_specs)){
    feature_list_model <- get_model_specs(model)
  } else {
    feature_list_model <- get_model_specs.default("")
  }

  internal <- process_all_data(internal,feature_list_model)

  return(internal)
}

#' @keywords internal
get_parameters <- function(approach,prediction_zero,n_combinations,group,n_samples,n_batches,seed,keep_samp_for_vS,...){
  parameters <- list(approach = approach,
                     prediction_zero = prediction_zero,
                     n_combinations = n_combinations,
                     group = group,
                     n_samples = n_samples,
                     n_batches = n_batches,
                     seed = seed,
                     keep_samp_for_vS = keep_samp_for_vS)
  parameters <- append(parameters,list(...))
  if(is.null(parameters$ignore_model)){
    parameters$ignore_model <- FALSE
  }
  parameters$exact <- ifelse(is.null(parameters$n_combinations), TRUE, FALSE)

  # TODO: Add any additional internal parameters here
  # TODO: Add testing of correct format for the input here

  #if (n_batches < 1 || n_batches > nrow(explainer$S)) {
  #  stop("`n_batches` is smaller than 1 or greater than the number of rows in explainer$S.")
  #}


  return(parameters)
}

#' @keywords internal
get_data <- function(x_train,x_explain){

  # Check format for x_train
  if (!is.matrix(x_train) & !is.data.frame(x_train)) {
    stop("x_train should be a matrix or a dataframe.")
  }
  # Check format of x_explain
  if (!is.matrix(x_explain) & !is.data.frame(x_explain)) {
    stop("x should be a matrix or a data.frame/data.table.")
  }

  data <- list(x_train = x_train,
               x_explain = x_explain)
}

get_funcs <- function(predict_model,get_model_specs,class_model,ignore_model){

  model_class <- NULL # due to NSE

  funcs <- list(predict_model = predict_model,
                get_model_specs = get_model_specs)

  supported_models <- get_supported_models()

  if(!ignore_model){
    if(is.null(funcs$predict_model)){
      native_func_available <- supported_models[predict_model==TRUE,class_model %in% model_class]
      if(native_func_available){
        funcs$predict_model <- get(paste0("predict_model.",class_model))
      } else {
        stop(
          "You passed a model to explain() which is not natively supported. See ?shapr::explain or the vignette\n",
          "for more information on how to run shapr with custom models."
        )
      }
    }

    if(is.null(funcs$get_model_specs)){
      native_func_available <- supported_models[get_model_specs==TRUE,class_model %in% model_class]
      if(native_func_available){
        funcs$get_model_specs <- get(paste0("get_model_specs.",class_model))
      } else {
        message(
          "Note: You passed a model to explain() that is not natively supported.\n",
          "By default, all feature consistency checking is thus disabled.\n",
          "This can be enabled for your custom model by passing a 'get_model_specs' function as an argument to explain(),\n",
          "see ?shapr::explain for further details."
        )
      }
    }
  }

  return(funcs)
}


#' @keywords internal
process_all_data <- function(internal,feature_list){

  # process x_train
  processed_list <- preprocess_data(
    x = internal$data$x_train,
    feature_list = feature_list
  )

  internal$data$x_train <- processed_list$x_dt
  internal$parameters$feature_list <- processed_list$updated_feature_list

  # process x_explain
  internal$data$x_explain <- preprocess_data(internal$data$x_explain,
                                             internal$parameters$feature_list)$x_dt

  # get number of features and observationst to explain
  internal$parameters$n_features <- ncol(internal$data$x_explain)
  internal$parameters$n_explain <-  nrow(internal$data$x_explain)
  internal$parameters$n_train <-  nrow(internal$data$x_train)


  # Processes groups if specified. Otherwise do nothing
  internal$parameters$is_groupwise <- !is.null(internal$parameters$group)
  if (internal$parameters$is_groupwise) {
    group_list <- process_groups(
      group = internal$parameters$group,
      feature_labels = internal$parameters$feature_list$labels
    )
    internal$parameters$group <- group_list$group
    internal$parameters$group_num <- group_list$group_num
  }
  return(internal)
}

#' Process (check and update) data according to specified feature list
#'
#' @param x matrix, data.frame or data.table. The data to check input for and update
#' according to the specification in \code{feature_list}.
#' @param feature_list List. Output from running \code{\link[shapr:get_data_specs]{get_data_specs}} or
#' \code{\link[shapr:get_model_specs]{get_model_specs}}
#'
#' @details This function takes care of all preprocessing and checking of the provided data in \code{x} against
#' the feature_list which is typically the output from \code{\link[shapr:get_model_specs]{get_model_specs}}
#'
#' @return List with two named elements: \code{x_dt}: Checked and updated data \code{x} in data.table format, and
#' \code{update_feature_list} the output from \code{\link[shapr:check_features]{check_features}}
#'
#' @author Martin Jullum
#'
#' @keywords internal
#' @export
#'
#' @examples
#' # Load example data
#' if (requireNamespace("MASS", quietly = TRUE)) {
#'   data("Boston", package = "MASS")
#'   # Split data into test- and training data
#'   x_train <- data.table::as.data.table(head(Boston))
#'   x_train[, rad := as.factor(rad)]
#'   data_features <- get_data_specs(x_train)
#'   model <- lm(medv ~ lstat + rm + rad + indus, data = x_train)
#'
#'   model_features <- get_model_specs(model)
#'   preprocess_data(x_train, model_features)
#' }
preprocess_data <- function(x, feature_list) {
  if (all(is.null(colnames(x)))) {
    stop(paste0("The data is missing column names"))
  }

  x_dt <- data.table::as.data.table(x)

  feature_list_data <- get_data_specs(x_dt)
  feature_list_data$specs_type <- "data"

  updater <- check_features(feature_list, feature_list_data,
                            use_1_as_truth = T
  )
  update_data(x_dt, updater) # Updates x_dt by reference



  ret <- list(
    x_dt = x_dt,
    updated_feature_list = updater
  )

  return(ret)
}

#' Checks that two extracted feature lists have exactly the same properties
#'
#' @param f_list_1,f_list_2 List. As extracted from either \code{get_data_specs} or \code{get_model_specs}.
#' @param use_1_as_truth Logical. If TRUE, \code{f_list_2} is compared to \code{f_list_1}, i.e. additional elements
#' is allowed in \code{f_list_2}, and if \code{f_list_1}'s feature classes contains NAs, feature class check is
#' ignored regardless of what is specified in \code{f_list_1}. If FALSE, \code{f_list_1} and \code{f_list_2} are
#' equated and they need to contain exactly the same elements. Set to TRUE when comparing a model and data, and FALSE
#' when comparing two data sets.
#'
#' @return List. The \code{f_list_1} is returned as inserted if there all check are carried out. If some info is
#' missing from \code{f_list_1}, the function continues consistency checking using \code{f_list_2} and returns that.
#'
#' @author Martin Jullum
#'
#' @keywords internal
#' @export
#'
#' @examples
#' # Load example data
#' if (requireNamespace("MASS", quietly = TRUE)) {
#'   data("Boston", package = "MASS")
#'   # Split data into test- and training data
#'   x_train <- data.table::as.data.table(head(Boston))
#'   x_train[, rad := as.factor(rad)]
#'   data_features <- get_data_specs(x_train)
#'   model <- lm(medv ~ lstat + rm + rad + indus, data = x_train)
#'
#'   model_features <- get_model_specs(model)
#'   check_features(model_features, data_features)
#' }
check_features <- function(f_list_1, f_list_2,
                           use_1_as_truth = T) {
  if (is.null(f_list_1$specs_type)) {
    f_list_1$specs_type <- "model"
  }

  if (is.null(f_list_2$specs_type)) {
    f_list_2$specs_type <- "model"
  }

  name_1 <- f_list_1$specs_type
  name_2 <- f_list_2$specs_type

  if (name_1 == name_2) { # If used in explain after a model has NA-info during check in shapr
    name_1 <- paste0(name_1, "_train")
    name_2 <- paste0(name_2, "_test")
  }

  #### Checking that labels exists if required, otherwise stop or switch ####
  NULL_1 <- is.null(f_list_1$labels)
  NULL_2 <- is.null(f_list_2$labels)

  if (NULL_2 | (NULL_1 & !use_1_as_truth)) {
    stop(paste0("The ", name_1, " or ", name_2, " have missing column names. Handle that to proceed."))
  }
  if (NULL_1 & use_1_as_truth) {
    message(paste0(
      "\nSuccess with message:\n",
      "The specified ", name_1, " provides NULL feature labels. ",
      "The labels of ", name_2, " are taken as the truth."
    ))
    f_list_1 <- f_list_2
  }

  NA_1 <- any(is.na(f_list_1$labels))
  NA_2 <- any(is.na(f_list_2$labels))

  if ((NA_1 & NA_2) | ((NA_1 | NA_2) & !use_1_as_truth)) {
    stop(paste0("The ", name_1, " or ", name_2, " have column names that are NA. Handle that to proceed."))
  }
  if ((NA_1 & use_1_as_truth)) {
    message(paste0(
      "\nSuccess with message:\n",
      "The specified ", name_1, " provides feature labels that are NA. ",
      "The labels of ", name_2, " are taken as the truth."
    ))
    f_list_1 <- f_list_2
  }

  # feature names must be unique
  if (any(duplicated(f_list_1$labels))) {
    stop(paste0(name_1, " must have unique column names."))
  }

  # feature names must be unique
  if (any(duplicated(f_list_2$labels))) {
    stop(paste0(name_2, " must have unique column names."))
  }


  feat_in_1_not_in_2 <- f_list_1$labels[!(f_list_1$labels %in% f_list_2$labels)]
  feat_in_2_not_in_1 <- f_list_2$labels[!(f_list_2$labels %in% f_list_1$labels)]

  # Check that the features in 1 are in 2
  if (length(feat_in_1_not_in_2) > 0) {
    stop(
      paste0(
        "Feature(s) ",
        paste0(feat_in_1_not_in_2, collapse = ", "),
        " in ", name_1, " is not in ", name_2, "."
      )
    )
  }

  # Also check that the features in 2 are in 1
  if (!use_1_as_truth) {
    if (length(feat_in_2_not_in_1) > 0) {
      stop(
        paste0(
          "Feature(s) ",
          paste0(feat_in_2_not_in_1, collapse = ", "),
          " in ", name_2, " is not in ", name_1, "."
        )
      )
    }
  }

  # Check if any features have empty names i.e ""
  if (any(f_list_1$labels == "")) {
    stop("One or more features is missing a name.")
  }

  # Order classes and factor levels in the same way as labels
  # for f_list_1
  order_1 <- match(f_list_1$labels, names(f_list_1$classes))
  f_list_1$classes <- f_list_1$classes[order_1]
  f_list_1$factor_levels <- f_list_1$factor_levels[order_1]

  # for f_list_2
  order_2 <- match(f_list_2$labels, names(f_list_2$classes))
  f_list_2$classes <- f_list_2$classes[order_2]
  f_list_2$factor_levels <- f_list_2$factor_levels[order_2]

  # Reorder f_List_2 to match f_list_1, also removing anything in the former which is not in the latter ####
  f_list_2_reordering <- match(f_list_1$labels, f_list_2$labels)

  f_list_2$labels <- f_list_2$labels[f_list_2_reordering]
  f_list_2$classes <- f_list_2$classes[f_list_2_reordering]
  f_list_2$factor_levels <- f_list_2$factor_levels[f_list_2_reordering]

  # Sorts the factor levels for easier comparison below
  f_list_1$sorted_factor_levels <- lapply(f_list_1$factor_levels, FUN = sort)
  f_list_2$sorted_factor_levels <- lapply(f_list_2$factor_levels, FUN = sort)


  #### Checking classes ####
  if (any(is.na(f_list_1$classes)) & use_1_as_truth) { # Only relevant when f_list_1 is a model
    message(paste0(
      "\nSuccess with message:\n",
      "The specified ", name_1, " provides feature classes that are NA. ",
      "The classes of ", name_2, " are taken as the truth."
    ))
    f_list_1 <- f_list_2
  }
  # Check if f_list_1 and f_list_2 have features with the same class
  if (!identical(f_list_1$classes, f_list_2$classes)) {
    stop(paste0("The features in ", name_1, " and ", name_2, " must have the same classes."))
  }

  # Check if the features all have class "integer", "numeric" or "factor
  if (!all(f_list_1$classes %in% c("integer", "numeric", "factor"))) {
    invalid_class <- which(!(f_list_1$classes %in% c("integer", "numeric", "factor")))
    stop(paste0(
      "Feature(s) ", paste0(f_list_1$labels[invalid_class], collapse = ", "), " in ", name_1, " and ", name_2,
      " is not of class integer, numeric or factor."
    ))
  }

  #### Checking factor levels ####
  factor_classes <- which(f_list_1$classes == "factor")
  if (length(factor_classes) > 0) {
    relevant_factor_levels <- f_list_1$factor_levels[factor_classes]
    is_NA <- any(is.na(relevant_factor_levels))
    is_NULL <- any(is.null(relevant_factor_levels))
    if ((is_NA | is_NULL) & use_1_as_truth) {
      message(paste0(
        "\nSuccess with message:\n",
        "The specified ", name_1, " provides factor feature levels that are NULL or NA. ",
        "The factor levels of ", name_2, " are taken as the truth."
      ))
      f_list_1 <- f_list_2 # Always safe to switch as f_list_2 is based on data, and extracts correctly
    }
  }

  # Checking factor levels #
  if (!identical(f_list_1$sorted_factor_levels, f_list_2$sorted_factor_levels)) {
    stop(paste0("Some levels for factor features are not present in both ", name_1, " and ", name_2, "."))
  }

  f_list_1$sorted_factor_levels <- NULL # Not needed

  return(f_list_1) #
}


#' Fetches feature information from a given data set
#'
#' @param x matrix, data.frame or data.table The data to extract feature information from.
#'
#' @details This function is used to extract the feature information to be checked against the corresponding
#' information extracted from the model and other data sets. The function is called from
#' \code{\link[shapr:preprocess_data]{preprocess_data}}
#' and \code{\link[shapr:make_dummies]{make_dummies}}
#'
#' @return A list with the following elements:
#' \describe{
#'   \item{labels}{character vector with the feature names to compute Shapley values for}
#'   \item{classes}{a named character vector with the labels as names and the class types as elements}
#'   \item{factor_levels}{a named list with the labels as names and character vectors with the factor levels as elements
#'   (NULL if the feature is not a factor)}
#' }
#' @author Martin Jullum
#'
#' @keywords internal
#' @export
#'
#' @examples
#' # Load example data
#' if (requireNamespace("MASS", quietly = TRUE)) {
#'   data("Boston", package = "MASS")
#'   # Split data into test- and training data
#'   x_train <- data.table::as.data.table(head(Boston))
#'   x_train[, rad := as.factor(rad)]
#'   get_data_specs(x_train)
#' }
get_data_specs <- function(x) {
  x <- data.table::as.data.table(x)

  feature_list <- list()
  feature_list$labels <- names(x)
  feature_list$classes <- unlist(lapply(x, class))
  feature_list$factor_levels <- lapply(x, levels)

  # Defining all integer values as numeric
  feature_list$classes[feature_list$classes == "integer"] <- "numeric"

  return(feature_list)
}

#' Updates data by reference according to the updater argument.
#'
#' @description \code{data} is updated, i.e. unused columns and factor levels are removed as described in
#' \code{updater}. This is done by reference, i.e. updates the object being passed to data even if nothing is
#' returned by the function itself.
#'
#' @param data data.table. Data that ought to be updated.
#' @param updater List. The object should be the output from
#' \code{\link[shapr:check_features]{check_features}}.
#'
#'
#' @return NULL.
#'
#' @author Martin Jullum
#'
#' @keywords internal
#' @export
#'
#' @examples
#' # Load example data
#' if (requireNamespace("MASS", quietly = TRUE)) {
#'   data("Boston", package = "MASS")
#'   # Split data into test- and training data
#'   x_train <- data.table::as.data.table(head(Boston))
#'   x_train[, rad := as.factor(rad)]
#'   data_features <- get_data_specs(x_train)
#'   model <- lm(medv ~ lstat + rm + rad + indus, data = x_train)
#'
#'   model_features <- get_model_specs(model)
#'   updater <- check_features(model_features, data_features)
#'   update_data(x_train, updater)
#' }
update_data <- function(data, updater) {
  # Operates on data by reference, so no copying of data here

  new_labels <- updater$labels
  factor_levels <- updater$factor_levels

  # Reorder and delete unused columns
  cnms_remove <- setdiff(colnames(data), new_labels)
  if (length(cnms_remove) > 0) {
    message(paste0(
      "\nSuccess with message:\n",
      "The columns(s) ",
      paste0(cnms_remove, collapse = ", "),
      " is not used by the model and thus removed from the data."
    )
    )
    data[, (cnms_remove) := NULL]
  }
  data.table::setcolorder(data, new_labels)

  # Reorderes the factor levels
  if (any(updater$classes == "factor")) {
    org_factor_levels <- lapply(data, levels)
    identical_levels <- mapply(FUN = "identical", org_factor_levels, factor_levels)
    if (any(!identical_levels)) {
      changed_levels <- which(!identical_levels)
      message(paste0(
        "\nSuccess with message:\n",
        "Levels are reordered for the factor feature(s) ",
        paste0(new_labels[changed_levels], collapse = ", "), "."
      ))

      for (i in changed_levels) {
        data.table::set(data,
                        j = i,
                        value = factor(unlist(data[, new_labels[i], with = F], use.names = F), levels = factor_levels[[i]])
        )
      }
    }
  }

  return(NULL)
}


#' Process (check and update names) the group list
#'
#'
#' @param feature_labels Vector of characters. Contains the feature labels used by the model
#'
#' @details This function takes care of all preprocessing and checking of the provided data in \code{x} against
#' the feature_list which is typically the output from \code{\link[shapr:get_model_specs]{get_model_specs}}
#'
#' @return List with two named elements: \code{group}: The input, but with group names if non-existing,
#' \code{group_num} a corresponding group list with names replaced by feature number
#'
#' @author Martin Jullum
#'
#' @keywords internal
process_groups <- function(group, feature_labels) {
  check_groups(feature_labels, group)

  # Make group names if not existing
  if (is.null(names(group))) {
    message(
      "\nSuccess with message:\n
      Group names not provided. Assigning them the default names 'group1', 'group2', 'group3' etc.")
    names(group) <- paste0("group", seq_along(group))
  }

  # Make group list with numeric feature indicators
  group_num <- lapply(group, FUN = function(x) {
    match(x, feature_labels)
  })

  return(list(group = group, group_num = group_num))
}

#' Check that the group parameter has the right form and content
#'
#'
#' @param feature_labels Vector of characters. Contains the feature labels used by the model
#'
#' @return Error or NULL
#'
#' @keywords internal
check_groups <- function(feature_labels, group) {
  if (!is.list(group)) {
    stop("group must be a list")
  }

  group_features <- unlist(group)

  # Checking that the group_features are characters
  if (!all(is.character(group_features))) {
    stop("All components of group should be a character.")
  }

  # Check that all features in group are in feature labels or used by model
  if (!all(group_features %in% feature_labels)) {
    missing_group_feature <- group_features[!(group_features %in% feature_labels)]
    stop(
      paste0(
        "The group feature(s) ", paste0(missing_group_feature, collapse = ", "), " are not\n",
        "among the features specified by the model/data. Delete from group."
      )
    )
  }

  # Check that all feature used by model are in group
  if (!all(feature_labels %in% group_features)) {
    missing_features <- feature_labels[!(feature_labels %in% group_features)]
    stop(
      paste0(
        "The model/data feature(s) ", paste0(missing_features, collapse = ", "), " do not\n",
        "belong to one of the groups. Add to a group."
      )
    )
  }

  # Check uniqueness of group_features
  if (length(group_features) != length(unique(group_features))) {
    dups <- group_features[duplicated(group_features)]
    stop(
      paste0(
        "Feature(s) ", paste0(dups, collapse = ", "), " are found in more than one group or ",
        "multiple times per group.\n",
        "Make sure each feature is only represented in one group, and only once."
      )
    )
  }
  return(NULL)
}

